package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strconv"
	"strings"
)

func main() {
	f, err := os.Open("input.txt")
	if err != nil {
		log.Fatal(err)
	}
	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)
	var statements []statement
	for scanner.Scan() {
		line := scanner.Text()
		fields := strings.Split(line, " ")
		var needB bool
		var st statement
		switch fields[0] {
		case "inp":
			st = statement{in: inp}
		case "add":
			needB = true
			st = statement{in: add}
		case "mul":
			needB = true
			st = statement{in: mul}
		case "div":
			needB = true
			st = statement{in: div}
		case "mod":
			needB = true
			st = statement{in: mod}
		case "eql":
			needB = true
			st = statement{in: eql}
		}
		st.a = strings.TrimSpace(fields[1])
		if needB {
			i, err := strconv.Atoi(fields[2])
			if err != nil {
				st.bStr = strings.TrimSpace(fields[2])
			} else {
				st.bIsInt = true
				st.bVal = i
			}
		}
		statements = append(statements, st)
	}
	i := 99999966200000
	for {
		if run(statements, strconv.Itoa(i)) {
			fmt.Println(i)
			break
		}
		i-- // "13579246899999")
		if i%100000 == 0 {
			fmt.Println("...", i)
		}
	}
}

type registers struct {
	w, x, y, z int
}

func (r registers) get(reg string) int {
	if reg == "w" {
		return r.w
	} else if reg == "x" {
		return r.x
	} else if reg == "y" {
		return r.y
	} else if reg == "z" {
		return r.z
	}
	fmt.Printf("unknown register %q\n", reg)
	return 0
}

func (r *registers) set(reg string, val int) {
	if reg == "w" {
		r.w = val
	} else if reg == "x" {
		r.x = val
	} else if reg == "y" {
		r.y = val
	} else if reg == "z" {
		r.z = val
	} else {
		fmt.Printf("unknown register %q\n", reg)
	}
}

func getB(st statement, reg registers) int {
	if st.bIsInt {
		return st.bVal
	}
	return reg.get(st.bStr)
}

func run(program []statement, input string) bool {
	var reg registers
	for _, st := range program {
		switch st.in {
		case inp:
			reg.set(st.a, int(input[0]-'0'))
			input = input[1:]
		case add:
			reg.set(st.a, reg.get(st.a)+getB(st, reg))
		case mul:
			reg.set(st.a, reg.get(st.a)*getB(st, reg))
		case div:
			reg.set(st.a, reg.get(st.a)/getB(st, reg))
		case mod:
			reg.set(st.a, reg.get(st.a)%getB(st, reg))
		case eql:
			if reg.get(st.a) == getB(st, reg) {
				reg.set(st.a, 1)
			} else {
				reg.set(st.a, 0)
			}
		}
	}
	// fmt.Println(reg)
	return reg.z == 0
}

type statement struct {
	in     instruction
	a      string
	bIsInt bool
	bStr   string
	bVal   int
}

type instruction int

const (
	inp instruction = iota
	add
	mul
	div
	mod
	eql
)

// codegen
func pgm(i int) {
inp w
mul x 0
add x z
mod x 26
div z 1
add x 15
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 4
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 14
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 16
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 11
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 14
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -13
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 3
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 14
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 11
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 15
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 13
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -7
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 11
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 10
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 7
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -12
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 12
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 1
add x 15
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 15
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -16
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 13
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -9
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 1
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -8
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 15
mul y x
add z y
inp w
mul x 0
add x z
mod x 26
div z 26
add x -8
eql x w
eql x 0
mul y 0
add y 25
mul y x
add y 1
mul z y
mul y 0
add y w
add y 4
mul y x
add z y
}